modas <- c() # Vector para almacenar las modas
# Encontrar los intervalos que contienen modas
intervalos_moda <- which(datos_agrupados$freq_table$fi_abs == max(datos_agrupados$freq_table$fi_abs))
# Calcular la moda para cada intervalo
for (intervalo in intervalos_moda) {
if (intervalo == 1) {
fi_a <- 0
} else {
fi_a <- datos_agrupados$freq_table$fi_abs[intervalo - 1]
}
if (intervalo == length(datos_agrupados$L)-1) {
fi_s <- 0
} else {
fi_s <- datos_agrupados$freq_table$fi_abs[intervalo + 1]
}
Li <- datos_agrupados$L[intervalo]
fi <- datos_agrupados$freq_table$fi_abs[intervalo]
A <- datos_agrupados$L[2] - datos_agrupados$L[1]
moda <- Li + ((fi - fi_a) / ((fi - fi_a) + (fi - fi_s))) * A
modas <- c(modas, moda) # Almacenar la moda calculada
}
return(modas)
}
calcular_cuantiles <- function(datos_agrupados, q, k) {
# Verificar que q sea un valor válido
if (!(q %in% c(4, 10, 100))) {
stop("El valor de q debe ser un entero y debe ser 4, 10 o 100.")
}
# verificar que k sea un entero y este estre 1 y q
if (!(k %in% seq(1:q))) {
stop(paste("El valor de k debe ser un entero entre 1 y ", q, ".", sep=""))
}
# Tamaño total de la muestra
n <- sum(datos_agrupados$freq_table$fi_abs)
# Calcular la posición del cuantil
quantile_pos <- (k * n) / q
# Encontrar el intervalo que contiene el cuantil
intervalo <- which.max(datos_agrupados$freq_table$Fi_abs >= quantile_pos)
if(intervalo == 1){
Fi_1 <- 0
} else{
Fi_1 <- datos_agrupados$freq_table$Fi_abs[intervalo - 1]
}
# Obtener los datos del intervalo que contiene el cuantil
Li <- datos_agrupados$L[intervalo]
fi <- datos_agrupados$freq_table$fi_abs[intervalo]
A <- (datos_agrupados$L[2]-datos_agrupados$L[1])
# Calcular el cuantil
cuantil <- Li + ((quantile_pos - Fi_1) / fi) * A
return(cuantil)
}
################################################################################
# script para agrupar datos y hacer un análisis descriptivo.
#
# Probabilidad y estadística
# Universidad de Nariño
#
# Realizado por: Santigo Jiménez Ramos
#
# Uso libre
################################################################################
# Función para obtener el primer dígito decimal de un número real
primer_digito_decimal <- function(numero) {
# Convertir el número a una cadena
cadena <- as.character(numero)
# Encontrar la posición del punto decimal
posicion_decimal <- stringr::str_locate(cadena, "\\.")[[1,1]]
# Si no hay punto decimal, devolver 0
if (is.na(posicion_decimal)) {
return(0)
}
# Obtener el primer dígito después del punto decimal
primer_digito <- substr(cadena, posicion_decimal + 1, posicion_decimal + 1)
# Devolver el dígito como número
return(as.numeric(primer_digito))
}
# Función para aproximar k al techo o al piso según el primer dígito decimal
aproximar <- function(k) {
if (as.numeric(substr(k, 1, 1)) %% 2 == 0) {
return(ceiling(k))
} else {
return(floor(k))
}
}
tabla_agrupada <- function(datos) {
# Calcular el número de intervalos de clases según la regla de Sturges
n <- length(datos)
k <- 1 + 3.322 * log10(n)
# Aproximar k al techo o al piso según el primer dígito decimal
k_new <- aproximar(k)
# Calcular rango, amplitud e intervalos
rango <- diff(range(datos)) #esto es lo mismo que haces max(datos)-min(datos)
amplitud <- rango / k_new
#Crear una nueva lista con la marca de clase
L <- seq(min(datos), max(datos), by = amplitud)
mc <- (L[-1] + L[-length(L)]) / 2 #calculamos la marca de clase
# Crear la tabla de frecuencias de datos agrupados
intervalos <- cut(datos, breaks = k_new, right = FALSE, include.lowest = TRUE)
freq_table <- as.data.frame(table(intervalos))
names(freq_table) <- c("Edad", "fi_abs")
# Calcular frecuencia acumulada absoluta
freq_table$Fi_abs <- cumsum(freq_table$fi_abs)
# Calcular frecuencia relativa
freq_table$fi_rel <- freq_table$fi_abs/n
# Calcular frecuencia acumulada relativa
freq_table$Fi_rel <- cumsum(freq_table$fi_rel)
#unir a la tabla la marca de clase
freq_table$Mc <- mc
# Imprimir resumen de estadísticas
cat("x_(1):", min(datos), "\n")
cat("x_(n):", max(datos), "\n")
cat("k    :", k_new, "\n")
cat("r(x) :", rango, "\n")
cat("A    :", amplitud, "\n\n")
# Devolver la tabla de frecuencias y la lista L
return(list(freq_table = freq_table, L = L))
}
# Calcular la media para datos agrupados
calcular_media <- function(datos_agrupados){
media <- sum((datos_agrupados$Mc*datos_agrupados$fi_abs))/(length(muestra))
return(media)
}
#funcion para calcular la mediana
calcular_mediana <- function(datos_agrupados) {
# Tamaño total de la muestra
n <- sum(datos_agrupados$freq_table$fi_abs)
# Calcular la posición de la mediana
mediana_pos <- n / 2
# Encontrar el intervalo que contiene la mediana
intervalo <- which.max(datos_agrupados$freq_table$Fi_abs >= mediana_pos)
if(intervalo == 1){
Fi_1 <- 0
} else{
Fi_1 <- datos_agrupados$freq_table$Fi_abs[intervalo - 1]
}
# Obtener los datos del intervalo que contiene la mediana
Li <- datos_agrupados$L[intervalo]
fi <- datos_agrupados$freq_table$fi_abs[intervalo]
A <- (datos_agrupados$L[2]-datos_agrupados$L[1])
# Calcular la mediana
mediana <- Li + ((mediana_pos - Fi_1) / fi) * A
return(mediana)
}
calcular_modas <- function(datos_agrupados){
modas <- c() # Vector para almacenar las modas
# Encontrar los intervalos que contienen modas
intervalos_moda <- which(datos_agrupados$freq_table$fi_abs == max(datos_agrupados$freq_table$fi_abs))
# Calcular la moda para cada intervalo
for (intervalo in intervalos_moda) {
if (intervalo == 1) {
fi_a <- 0
} else {
fi_a <- datos_agrupados$freq_table$fi_abs[intervalo - 1]
}
if (intervalo == length(datos_agrupados$L)-1) {
fi_s <- 0
} else {
fi_s <- datos_agrupados$freq_table$fi_abs[intervalo + 1]
}
Li <- datos_agrupados$L[intervalo]
fi <- datos_agrupados$freq_table$fi_abs[intervalo]
A <- datos_agrupados$L[2] - datos_agrupados$L[1]
moda <- Li + ((fi - fi_a) / ((fi - fi_a) + (fi - fi_s))) * A
modas <- c(modas, moda) # Almacenar la moda calculada
}
return(modas)
}
calcular_cuantiles <- function(datos_agrupados, q, k) {
# Verificar que q sea un valor válido
if (!(q %in% c(4, 10, 100))) {
stop("El valor de q debe ser un entero y debe ser 4, 10 o 100.")
}
# verificar que k sea un entero y este estre 1 y q
if (!(k %in% seq(1:q))) {
stop(paste("El valor de k debe ser un entero entre 1 y ", q, ".", sep=""))
}
# Tamaño total de la muestra
n <- sum(datos_agrupados$freq_table$fi_abs)
# Calcular la posición del cuantil
quantile_pos <- (k * n) / q
# Encontrar el intervalo que contiene el cuantil
intervalo <- which.max(datos_agrupados$freq_table$Fi_abs >= quantile_pos)
if(intervalo == 1){
Fi_1 <- 0
} else{
Fi_1 <- datos_agrupados$freq_table$Fi_abs[intervalo - 1]
}
# Obtener los datos del intervalo que contiene el cuantil
Li <- datos_agrupados$L[intervalo]
fi <- datos_agrupados$freq_table$fi_abs[intervalo]
A <- (datos_agrupados$L[2]-datos_agrupados$L[1])
# Calcular el cuantil
cuantil <- Li + ((quantile_pos - Fi_1) / fi) * A
return(cuantil)
}
tabla_agrupada()
View(tabla_agrupada)
View(tabla_agrupada)
# Encontrar el intervalo que contiene la mediana
intervalo <- which.max(datos_agrupados$freq_table$Fi_abs >= mediana_pos)
View(tabla_agrupada)
View(tabla_agrupada)
function(datos) {
# Calcular el número de intervalos de clases según la regla de Sturges
n <- length(datos)
k <- 1 + 3.322 * log10(n)
# Aproximar k al techo o al piso según el primer dígito decimal
k_new <- aproximar(k)
# Calcular rango, amplitud e intervalos
rango <- diff(range(datos)) #esto es lo mismo que haces max(datos)-min(datos)
amplitud <- rango / k_new
#Crear una nueva lista con la marca de clase
L <- seq(min(datos), max(datos), by = amplitud)
mc <- (L[-1] + L[-length(L)]) / 2 #calculamos la marca de clase
# Crear la tabla de frecuencias de datos agrupados
intervalos <- cut(datos, breaks = k_new, right = FALSE, include.lowest = TRUE)
freq_table <- as.data.frame(table(intervalos))
names(freq_table) <- c("Edad", "fi_abs")
# Calcular frecuencia acumulada absoluta
freq_table$Fi_abs <- cumsum(freq_table$fi_abs)
# Calcular frecuencia relativa
freq_table$fi_rel <- freq_table$fi_abs/n
# Calcular frecuencia acumulada relativa
freq_table$Fi_rel <- cumsum(freq_table$fi_rel)
#unir a la tabla la marca de clase
freq_table$Mc <- mc
# Imprimir resumen de estadísticas
cat("x_(1):", min(datos), "\n")
cat("x_(n):", max(datos), "\n")
cat("k    :", k_new, "\n")
cat("r(x) :", rango, "\n")
cat("A    :", amplitud, "\n\n")
# Devolver la tabla de frecuencias y la lista L
return(list(freq_table = freq_table, L = L))
}
View(tabla_agrupada)
function(datos) {
# Calcular el número de intervalos de clases según la regla de Sturges
n <- length(datos)
k <- 1 + 3.322 * log10(n)
# Aproximar k al techo o al piso según el primer dígito decimal
k_new <- aproximar(k)
# Calcular rango, amplitud e intervalos
rango <- diff(range(datos)) #esto es lo mismo que haces max(datos)-min(datos)
amplitud <- rango / k_new
#Crear una nueva lista con la marca de clase
L <- seq(min(datos), max(datos), by = amplitud)
mc <- (L[-1] + L[-length(L)]) / 2 #calculamos la marca de clase
# Crear la tabla de frecuencias de datos agrupados
intervalos <- cut(datos, breaks = k_new, right = FALSE, include.lowest = TRUE)
freq_table <- as.data.frame(table(intervalos))
names(freq_table) <- c("Edad", "fi_abs")
# Calcular frecuencia acumulada absoluta
freq_table$Fi_abs <- cumsum(freq_table$fi_abs)
# Calcular frecuencia relativa
freq_table$fi_rel <- freq_table$fi_abs/n
# Calcular frecuencia acumulada relativa
freq_table$Fi_rel <- cumsum(freq_table$fi_rel)
#unir a la tabla la marca de clase
freq_table$Mc <- mc
# Imprimir resumen de estadísticas
cat("x_(1):", min(datos), "\n")
cat("x_(n):", max(datos), "\n")
cat("k    :", k_new, "\n")
cat("r(x) :", rango, "\n")
cat("A    :", amplitud, "\n\n")
# Devolver la tabla de frecuencias y la lista L
return(list(freq_table = freq_table, L = L))
}
function(datos) {
# Calcular el número de intervalos de clases según la regla de Sturges
n <- length(datos)
k <- 1 + 3.322 * log10(n)
# Aproximar k al techo o al piso según el primer dígito decimal
k_new <- aproximar(k)
# Calcular rango, amplitud e intervalos
rango <- diff(range(datos)) #esto es lo mismo que haces max(datos)-min(datos)
amplitud <- rango / k_new
#Crear una nueva lista con la marca de clase
L <- seq(min(datos), max(datos), by = amplitud)
mc <- (L[-1] + L[-length(L)]) / 2 #calculamos la marca de clase
# Crear la tabla de frecuencias de datos agrupados
intervalos <- cut(datos, breaks = k_new, right = FALSE, include.lowest = TRUE)
freq_table <- as.data.frame(table(intervalos))
names(freq_table) <- c("Edad", "fi_abs")
# Calcular frecuencia acumulada absoluta
freq_table$Fi_abs <- cumsum(freq_table$fi_abs)
# Calcular frecuencia relativa
freq_table$fi_rel <- freq_table$fi_abs/n
# Calcular frecuencia acumulada relativa
freq_table$Fi_rel <- cumsum(freq_table$fi_rel)
#unir a la tabla la marca de clase
freq_table$Mc <- mc
# Imprimir resumen de estadísticas
cat("x_(1):", min(datos), "\n")
cat("x_(n):", max(datos), "\n")
cat("k    :", k_new, "\n")
cat("r(x) :", rango, "\n")
cat("A    :", amplitud, "\n\n")
# Devolver la tabla de frecuencias y la lista L
return(list(freq_table = freq_table, L = L))
}
function(datos) {
# Calcular el número de intervalos de clases según la regla de Sturges
n <- length(datos)
k <- 1 + 3.322 * log10(n)
# Aproximar k al techo o al piso según el primer dígito decimal
k_new <- aproximar(k)
# Calcular rango, amplitud e intervalos
rango <- diff(range(datos)) #esto es lo mismo que haces max(datos)-min(datos)
amplitud <- rango / k_new
#Crear una nueva lista con la marca de clase
L <- seq(min(datos), max(datos), by = amplitud)
mc <- (L[-1] + L[-length(L)]) / 2 #calculamos la marca de clase
# Crear la tabla de frecuencias de datos agrupados
intervalos <- cut(datos, breaks = k_new, right = FALSE, include.lowest = TRUE)
freq_table <- as.data.frame(table(intervalos))
names(freq_table) <- c("Edad", "fi_abs")
# Calcular frecuencia acumulada absoluta
freq_table$Fi_abs <- cumsum(freq_table$fi_abs)
# Calcular frecuencia relativa
freq_table$fi_rel <- freq_table$fi_abs/n
# Calcular frecuencia acumulada relativa
freq_table$Fi_rel <- cumsum(freq_table$fi_rel)
#unir a la tabla la marca de clase
freq_table$Mc <- mc
# Imprimir resumen de estadísticas
cat("x_(1):", min(datos), "\n")
cat("x_(n):", max(datos), "\n")
cat("k    :", k_new, "\n")
cat("r(x) :", rango, "\n")
cat("A    :", amplitud, "\n\n")
# Devolver la tabla de frecuencias y la lista L
return(list(freq_table = freq_table, L = L))
}
A <- (datos_agrupados$L[2]-datos_agrupados$L[1])
frec_absoluta <- table(datos_edades)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_agrupados.R", echo=TRUE)
View(tabla_agrupada)
View(tabla_agrupada)
source("C:/Programacion Universidad/Semestre 3/RStudio/graficos.R", echo=TRUE)
View(tabla_agrupados)
View(tabla_agrupada)
View(g1)
View(datos_barras)
View(datos_barras)
View(aproximar)
View(calcular_media)
lanzamiento_dados <- data.frame(dado1=sample(1:6,1000,replace=TRUE),dado2 = sample(1:6,1000,replace = TRUE))
lanzamiento_dados
pares
pares
pares <- mean((lanzamiento_dados$dado1 == lanzamiento_dados$dado2))
pares
source("C:/Programacion Universidad/Semestre 3/RStudio/tabla de frecuencias.R", echo=TRUE)
# Cargar y dejar disponibles los datos llamados iris
data(iris)
# Descripción de los datos y significado de cada variable
?iris
# Clasificación de variables
str(iris)
# Análisis unidimensional de cada variable
summary(iris)
# Análisis bidimensional para establecer relaciones entre las variables
pairs(iris[1:4], main="Scatterplot Matrix")
# Relación de variables con un gráfico de dispersión
library(ggplot2)
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point() +
labs(title = "Relación entre Sepal Length y Sepal Width por Especie")
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
# Cargar y dejar disponibles los datos llamados iris
data(iris)
print(head(iris)) # Visualizar las primeras filas para confirmar la carga
# Descripción de los datos y significado de cada variable
# Este comando abrirá la ayuda donde se describe el dataset Iris en detalle
?iris
# Clasificación de variables - ver estructura del dataset
str(iris)
# Análisis unidimensional de cada variable
# Esto proporcionará estadísticas descriptivas básicas para cada variable
summary(iris)
# Análisis bidimensional para establecer relaciones entre las variables
# Generando una matriz de scatterplots para visualizar relaciones potenciales
pairs(iris[1:4], main = "Matrix de Dispersión para Iris", pch = 21, bg = c("#1b9e77", "#d95f02", "#7570b3")[unclass(iris$Species)])
# Mejorando el gráfico de dispersión con ggplot2
library(ggplot2)
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point(alpha = 0.5, size = 3) +  # Ajustando transparencia y tamaño del punto
labs(title = "Relación entre Sepal Length y Sepal Width por Especie de Iris",
x = "Longitud del Sépalo (cm)",
y = "Ancho del Sépalo (cm)") +
theme_minimal() + # Usando un tema minimalista
scale_color_manual(values = c("Verde" = "#1b9e77", "Tomate" = "#d95f02", "Morado" = "#7570b3")) # Colores personalizados por especie
# Cargar y dejar disponibles los datos llamados iris
data(iris)
print(head(iris)) # Visualizar las primeras filas para confirmar la carga
# Descripción de los datos y significado de cada variable
# Este comando abrirá la ayuda donde se describe el dataset Iris en detalle
?iris
# Clasificación de variables - ver estructura del dataset
str(iris)
# Análisis unidimensional de cada variable
# Esto proporcionará estadísticas descriptivas básicas para cada variable
summary(iris)
# Análisis bidimensional para establecer relaciones entre las variables
# Generando una matriz de scatterplots para visualizar relaciones potenciales
pairs(iris[1:4], main = "Matrix de Dispersión para Iris", pch = 21, bg = c("#1b9e77", "#d95f02", "#7570b3")[unclass(iris$Species)])
# Mejorando el gráfico de dispersión con ggplot2
library(ggplot2)
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point(alpha = 0.5, size = 3) +  # Ajustando transparencia y tamaño del punto
labs(title = "Relación entre Sepal Length y Sepal Width por Especie de Iris",
x = "Longitud del Sépalo (cm)",
y = "Ancho del Sépalo (cm)") +
theme_minimal() + # Usando un tema minimalista
scale_color_manual(values = c("Verde" = "#1b9e77", "Tomate" = "#d95f02", "Morado" = "#7570b3")) # Colores personalizados por especie
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
head(ejercicio)
datos <- tabla_agrupada(n_clientes)
datos
setwd("C:\Programacion Universidad\Semestre 3\RStudio\datos_clase.txt.txt")
# Descripción de los datos y significado de cada variable
# Este comando abrirá la ayuda donde se describe el dataset Iris en detalle
?iris
source("C:/Programacion Universidad/Semestre 3/RStudio/datairis.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
datos <- tabla_agrupada(n_clientes)
setwd("C:\Programacion Universidad\Semestre 3\RStudio\datos_clase.txt.txt")
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
datos <- tabla_agrupada(n_clientes)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
setwd("C:/Programacion Universidad/Semestre 3/RStudio")
ejercicio <- read.table("datos_clase.txt", header = TRUE)
setwd("C:/Programacion Universidad/Semestre 3/RStudio")
ejercicio <- read.table("datos_clase.txt", header = TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
setwd("C:/Programacion Universidad/Semestre 3/RStudio")
ejercicio <- read.table("datos.txt", header = TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
setwd("C:/Programacion Universidad/Semestre 3/RStudio")
ejercicio <- read.table("datos.txt", header = TRUE)
setwd("C:/Programacion Universidad/Semestre 3/RStudio")
ejercicio <- read.table("datos.txt", header = TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
setwd("C://Programacion Universidad//Semestre 3//RStudio")
ejercicio <- read.table("datos.txt", header = TRUE)
setwd("C://Programacion Universidad//Semestre 3//RStudio")
ejercicio <- read.table("datos.txt", header = TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
view(ejercicio)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
# Set the working directory using forward slashes
setwd("C:/Programacion Universidad/Semestre 3/RStudio")
# Check the current working directory
getwd()
# List files in the working directory to confirm the file exists
dir()
# Read the file "datos_clase.txt"
ejercicio <- read.table("datos_clase.txt", header = TRUE)
# Set the working directory using forward slashes
setwd("C:/Programacion Universidad/Semestre 3/RStudio")
# Check the current working directory
getwd()
# List files in the working directory to confirm the file exists
dir()
# Read the file "datos_clase.txt"
ejercicio <- read.table("datos_clase.txt", header = TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
setwd("C:\\Programacion Universidad\\Semestre 3\\RStudio")
getwd()
dir()
ejercicio <- read.table("datos.txt", header = TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
setwd("C:\\Programacion Universidad\\Semestre 3\\RStudio")
ejercicio <- read.table("datos.txt", header = TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
ejercicio <- read.txt("C:\\Programacion Universidad\\Semestre 3\\RStudio\\datos.txt")
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
# Specify the full path to the file using double backslashes or forward slashes
file_path <- "C:\\Programacion Universidad\\Semestre 3\\RStudio\\datos.txt"
# Read the text file
ejercicio <- readLines(file_path)
source("C:/Programacion Universidad/Semestre 3/RStudio/datos_clase.r", echo=TRUE)
